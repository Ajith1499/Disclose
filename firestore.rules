/**
 * @file Firebase Security Rules for LocalThreads Application
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model for personal data,
 *                  while allowing public read access to product and shop information.
 *                  Write access to shops and products is currently open but should be
 *                  protected by shop ownership in a later iteration.
 *
 * @data_structure The data is organized hierarchically, with user-specific data nested
 *                 under `/users/{userId}`. Shop and product data reside in top-level
 *                 collections.
 *
 * @key_security_decisions
 *   - User listing is disallowed.
 *   - Product and Shop read access is public.
 *   - Write access to Shops and Products is currently unrestricted (TODO: Implement ownership).
 *   - Authorization decisions rely on the `request.auth` object for user identity.
 *   - Denormalization is used where necessary to avoid `get()` calls in rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by a signed-in user.
     * @example isSignedIn() == true if request.auth != null
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId - The user ID to compare against.
     * @example isOwner('user123') == (request.auth.uid == 'user123')
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of an existing document.
     *              This combines the ownership check with a document existence check,
     *              preventing operations on non-existent documents.
     * @param {string} userId - The user ID to compare against.
     * @example isExistingOwner('user123') == (request.auth.uid == 'user123' && resource != null)
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rule for user documents.
     * @path /users/{userId}
     * @allow (create) Signed-in user with matching userId in the path and document.
     * @allow (get, update, delete) Signed-in user with matching userId in the path.
     * @deny (create) Signed-in user with mismatched userId.
     * @deny (list) Anyone.
     * @principle Enforces document ownership for writes, restricts listing.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for shop documents.
     * @path /shops/{shopId}
     * @allow (get, list) Public read access.
     * @allow (create, update, delete) Any signed-in user. TODO: Restrict writes to shop owners.
     * @principle Public read, owner-only writes (TODO: Implement ownership).
     */
    match /shops/{shopId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rule for product documents.
     * @path /shops/{shopId}/products/{productId}
     * @allow (get, list) Public read access.
     * @allow (create, update, delete) Any signed-in user. TODO: Restrict writes to shop owners.
     * @principle Public read, owner-only writes (TODO: Implement ownership).
     */
    match /shops/{shopId}/products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rule for wishlist documents.
     * @path /users/{userId}/wishlists/{wishlistId}
     * @allow (create) Signed-in user with matching userId in the path and document.
     * @allow (get, list, update, delete) Signed-in user with matching userId in the path.
     * @deny (create) Signed-in user with mismatched userId.
     * @principle Enforces document ownership.
     */
    match /users/{userId}/wishlists/{wishlistId} {
      allow get, list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for wallet documents.
     * @path /users/{userId}/wallets/{walletId}
     * @allow (create) Signed-in user with matching userId in the path and document.
     * @allow (get, update, delete) Signed-in user with matching userId in the path.
     * @deny (create) Signed-in user with mismatched userId.
     * @principle Enforces document ownership.
     */
    match /users/{userId}/wallets/{walletId} {
      allow get, list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for transaction documents.
     * @path /users/{userId}/wallets/{walletId}/transactions/{transactionId}
     * @allow (create) Signed-in user with matching userId in the path and document.
     * @allow (get, list, update, delete) Signed-in user with matching userId in the path.
     * @deny (create) Signed-in user with mismatched userId.
     * @principle Enforces document ownership.
     */
    match /users/{userId}/wallets/{walletId}/transactions/{transactionId} {
      allow get, list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
  }
}